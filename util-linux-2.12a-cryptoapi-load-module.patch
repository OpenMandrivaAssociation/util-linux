--- mount/loop.c	2009-01-13 18:12:03.000000000 +0100
+++ mount/loop.c.oden	2009-01-13 18:12:09.000000000 +0100
@@ -12,7 +12,12 @@
 #include <ctype.h>
 #include <sys/ioctl.h>
 #include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <fcntl.h>
+#include <unistd.h>
 #include <errno.h>
+#include "nls.h"
 #include "loop.h"
 
 static void convert_info_to_info64(struct loop_info *info, struct loop_info64 *info64)
@@ -193,6 +198,32 @@ static char *getApiName(char *e, int *le
 	return((char *)s);
 }
 
+void load_module(char * module) {
+	pid_t x;
+	int y;
+	char * a[3];
+
+	if(!(x = fork())) {
+		if((x = open("/dev/null", O_WRONLY)) >= 0) {
+			dup2(x, 2);
+			close(x);
+		}
+		a[0] = "modprobe";
+		a[1] = module;
+		a[2] = NULL;
+		execvp(a[0], &a[0]);
+		execv("/sbin/modprobe", &a[0]);
+		/* error to stdout, stderr is directed to /dev/null */
+		printf(_("loop: unable to execute modprobe\n"));
+		exit(1);
+	}
+	if(x == -1) {
+		fprintf(stderr, _("loop: fork failed\n"));
+		return;
+	}
+	waitpid(x, &y, 0);
+}
+
 int loop_crypt_type(const char *name, u_int32_t *kbyp, char **apiName)
 {
 	int i, k;
@@ -209,6 +240,8 @@ int loop_crypt_type(const char *name, u_
 		}
 	}
 	*kbyp = 16; /* 128 bits */
+	load_module("cryptoloop");
+	load_module(*apiName);
 	return 18; /* LO_CRYPT_CRYPTOAPI */
 }
 
